#include "stdafx.h"
#include "FuzzyFilters.h"
#include <math.h>

using namespace System::Drawing;

	#ifdef _DEBUG
using namespace System::IO;
#endif

#pragma region Contrast Helper
/**
* Formula from http://www.proceedings2007.imcsit.org/pliks/144.pdf
* Applies the intensification formula to the given color of a pixel
* If input<=128, 2*input^2
* Otherwise, 1-2*(1-input)^2
* @param input - an unsigned char from 0-255
*
* @return the intensified version of the input pixel.
* Primary Coder: Brian Sweeney
*/
unsigned char contrastFormula(unsigned char input)
{
	double l = ((double)input)/(256.0);
	unsigned char ret;
	if(0<=l && l <=.5)
	{
		 ret = (unsigned char)(256.0*(2.0*l*l));
		return ret;
	}
	else
	{
		ret = (unsigned char)(256.0 * (1.0-2.0*(1.0-l)*(1.0-l)));
		return ret;
	}
}
/**
* Inverse formula from http://www.proceedings2007.imcsit.org/pliks/144.pdf
* Applies the inverse intensification formula to the given color of a pixel
* If input<=128, sqrt(input/2.0)
* else -1 * sqrt((1-input)/2+1)
* @param input - an unsigned char from 0-255
*
* @return the (inverse) intensified version of the input pixel.
* Primary Coder: Brian Sweeney
*/
unsigned char inverseContrastFormula(unsigned char input)
{
	double l = ((double)input)/(256.0);
	unsigned char ret;
	if(0<=l && l <=.5)
	{
		 ret = (unsigned char)(256.0*(sqrt(l/2.0)));
		return ret;
	}
	else
	{
		ret = (unsigned char)(256.0 * ((-1)*sqrt((1-l)/2)+1));
		return ret;
	}
}
#pragma endregion

/**
* Applies a fuzzy contrast filter using the intensification function from fuzzy sets
* @param picture - the picture to apply a filter too
* @param redBool - indicates if you want to constract the red channel
* @param greenBool - indicates if you want to constract the green channel
* @param blueBool - indicates if you want to constract the blue channel
*
* @return An image to which the contrast filter has been applied.
* Primary Coder: Brian Sweeney
*/
System::Drawing::Bitmap^ FuzzyFilters::Contrast(Bitmap ^ picture, bool redBool, bool greenBool, bool blueBool) //Brian S
{
	Bitmap ^ newBitMap = gcnew Bitmap(picture->Width,picture->Height);

			 for(int w = 0; w<picture->Width;w++)
			 {
				 for(int h = 0; h<picture->Height; h++)
				 {
					 Color ^ color = picture->GetPixel(w,h);
					 Color ^ newColor = gcnew Color();
					 unsigned char red = color->R;
					 unsigned char green = color->G;
					 unsigned char blue = color->B;
					 if(redBool)
						red = contrastFormula(color->R);
					 if(greenBool)
						 green = contrastFormula(color->G);
					 if(blueBool)
						 blue = contrastFormula(color->B);
					 newColor = newColor->FromArgb(red, green, blue);
					 
					 newBitMap->SetPixel(w,h, *newColor);
					 newColor = newBitMap->GetPixel(w,h);
					 						
				 }
			 }

	return newBitMap;
}
/**
* Applies a fuzzy contrast filter using the inverse intensification function from fuzzy sets
* @param picture - the picture to apply a filter too
* @param redBool - indicates if you want to constract the red channel
* @param greenBool - indicates if you want to constract the green channel
* @param blueBool - indicates if you want to constract the blue channel
*
* @return An image to which the inverse contrast filter has been applied.
* Primary Coder: Brian Sweeney
*/
System::Drawing::Bitmap^ FuzzyFilters::InverseContrast(Bitmap ^ picture, bool redBool, bool greenBool, bool blueBool) //Brian S
{
	Bitmap ^ newBitMap = gcnew Bitmap(picture->Width,picture->Height);
			 
			 for(int w = 0; w<picture->Width;w++)
			 {
				 for(int h = 0; h<picture->Height; h++)
				 {
					 Color ^ color = picture->GetPixel(w,h);
					 Color ^ newColor = gcnew Color(); 
					 unsigned char red = color->R;
					 unsigned char green = color->G;
					 unsigned char blue = color->B;
					 if(redBool)
						red = inverseContrastFormula(color->R);
					 if(greenBool)
						 green = inverseContrastFormula(color->G);
					 if(blueBool)
						blue = inverseContrastFormula(color->B);
					 newColor = newColor->FromArgb(red, green, blue);
					 
					 newBitMap->SetPixel(w,h, *newColor);
					 newColor = newBitMap->GetPixel(w,h);
								
				 }
			 }

	return newBitMap;
}

/**
  *  Creates an edgemap out of the image passed in.
  *  @param Image - The image to run the filter over
  *  @param sensitivity - Sets the sensitivity of the filter when detecting edges, where 0 is the highest sensitivity (most edges)
  *
  *  @return An edgemap generated by running the filter over the input image.
  * Primary Coder: Brian Dye
  */
System::Drawing::Bitmap ^ FuzzyFilters::EdgeDetection(System::Drawing::Bitmap ^ Image, int sensitivity) //Brian D
{
	
	int x = Image->Width;
	int y = Image->Height;
	System::Drawing::Bitmap ^ edgeImage = gcnew System::Drawing::Bitmap(x, y);
	float window = sensitivity * sensitivity;
	array<int, 2>^ edgeStr = gcnew array<int,2>(x, y);

	/**
	  * First Pass: 
	  * Looks for candidate edges in the image, a candidate edge is a pixel who's color has a greater distance from a neighbooring color greater than the sensitivity window.
	  */
	for(int i = 1; i < x - 1; i++)
	{
		for(int j = 1; j < y - 1; j++)
		{
			edgeStr[i, j] = 0;
			edgeImage->SetPixel(i, j, Color::Black);
			Color col = Image->GetPixel(i, j);
			Color comp;
			int temp = 0;
			
			comp = Image->GetPixel(i-1, j-1);
			if(window < (col.R - comp.R) * (col.R - comp.R) + (col.G - comp.G) * (col.G - comp.G) + (col.B - comp.B) * (col.B - comp.B)){
				temp++;
			}
			comp = Image->GetPixel(i, j-1);
			if(window < (col.R - comp.R) * (col.R - comp.R) + (col.G - comp.G) * (col.G - comp.G) + (col.B - comp.B) * (col.B - comp.B)){
				temp++;
			}
			comp = Image->GetPixel(i+1, j-1);
			if(window < (col.R - comp.R) * (col.R - comp.R) + (col.G - comp.G) * (col.G - comp.G) + (col.B - comp.B) * (col.B - comp.B)){
				temp++;
			}
			comp = Image->GetPixel(i-1, j);
			if(window < (col.R - comp.R) * (col.R - comp.R) + (col.G - comp.G) * (col.G - comp.G) + (col.B - comp.B) * (col.B - comp.B)){
				temp++;
			}
			comp = Image->GetPixel(i+1, j);
			if(window < (col.R - comp.R) * (col.R - comp.R) + (col.G - comp.G) * (col.G - comp.G) + (col.B - comp.B) * (col.B - comp.B)){
				temp++;
			}
			comp = Image->GetPixel(i-1, j+1);
			if(window < (col.R - comp.R) * (col.R - comp.R) + (col.G - comp.G) * (col.G - comp.G) + (col.B - comp.B) * (col.B - comp.B)){
				temp++;
			}
			comp = Image->GetPixel(i, j+1);
			if(window < (col.R - comp.R) * (col.R - comp.R) + (col.G - comp.G) * (col.G - comp.G) + (col.B - comp.B) * (col.B - comp.B)){
				temp++;
			}
			comp = Image->GetPixel(i+1, j+1);
			if(window < (col.R - comp.R) * (col.R - comp.R) + (col.G - comp.G) * (col.G - comp.G) + (col.B - comp.B) * (col.B - comp.B)){
				temp++;
			}
			if(temp != 8 && temp != 0){
				edgeStr[i, j]++;
			}
		}
	}

	/**
	  * Second Pass:
	  * Each candidate edge has their edge strength calculated by checking their neighboors for edge values.
	  * An edge who has neighboors that are also edges have a higher strength. The minimum strength for a candidate edge is 2.
	  */

	for(int i = 1; i < x - 1; i++)
	{
		for(int j = 1; j < y - 1; j++)
		{
			if(edgeStr[i,j] > 0){
				for(int k = -1; k < 2; k++){
					for(int l = -1; l < 2; l++){
						if(edgeStr[i + k, j + l] > 0)
							edgeStr[i,j]++;
					}
				}
				if(edgeStr[i,j] > 3 && edgeStr[i,j] < 9) edgeImage->SetPixel(i, j, Color::White);
			}
			
		}
	}

	return edgeImage;
}



#pragma region Noise Reduction

/**
* Helper Function For Noise Reduction, calculates the "distance" between individual color components of two pixels.
* @param Image - The image that Noise Reduction is being applied to
* @param i - An integer that together with j defines a specific pixel in Image
* @param j - see above.
* @param k - Used to access pixels that are part of a neighborhood centered around pixel (i,j)
* @param l - see above.
* @param ctype - Defines the color components of the individual pixels for which a distance is being calculated
*
* @return The "distance" between individual color components of two pixels
* Primary Coder: Carlos Salazar
*/
float FuzzyFilters::FindDistance(System::Drawing::Bitmap ^ Image, int i, int j, int k, int l, FuzzyFilters::coupleType ctype)
{
	if ((i+k) >= Image->Height || (i+k) < 0 || (j+l) >= Image->Width || (j+l) < 0) {
		return 0.0f;
	}

	Color px1 = Image->GetPixel(j+l,  i+k);
	Color px2 = Image->GetPixel(j, i);
	float a = 0;
	float b = 0;

	switch (ctype)
	{
	case FuzzyFilters::RedGreen:
		a = px1.R - px2.R;
		b = px1.G - px2.G;
		break;
	case FuzzyFilters::RedBlue:
		a = px1.R - px2.R;
		b = px1.B - px2.B;
		break;
	case FuzzyFilters::GreenBlue:
		a = px1.G - px2.G;
		b = px1.B - px2.B;
		break;
	default:
		break;
	}

	/* d is the "distance variable" where d=2 is euclidian distance */
	int d = 2;

	float c = pow(a, d) + pow(b, d);
	float ans = pow(c, (1/d));

	return ans;
}

/**
* Fuzzy Set Membership Function, determines if a distance is "small" or not.
* @param dist - A float representing the distance between particular color components of two pixels.
* @param p - A float representing the maximum distance for a given type of couple contained within a neighborhood.
*
* @return A float representing how "small" a distance is.
* Primary Coder: Carlos Salazar
*/
float FuzzyFilters::SmallMembershipFunction(float dist, float p)
{
	float ans = 0.0f;
	if (dist <= p)
	{
		float x = (p-dist)/p;
		ans = pow(x, 2);
	}
	
	return 1 - ans;
}


/**
* Each neighborhood around a pixel (i,j) has a p value which is used to calculate fuzzy set membership for those pixels.
* This p value is then used as an input for SmallMembershipFunction().
* @param Image - The image that Noise Reduction is being applied to
* @param i - An integer that together with j defines a specific pixel in Image
* @param j - see above.
* @param ctype - Defines the color components of the individual pixels for which a distance is being calculated
* @param bigK - Defines the size of a neighborhood. a neighborhood is (2*bigK + 1) x (2*bigK + 1) in size.  E.g. for bigK =1, we have a 3 x 3 neighborhood.
*
* @return the maximum distance for a given type of couple (e.g. RedGreen) contained within a neighborhood.
* Primary Coder: Carlos Salazar
*/
float FuzzyFilters::FindPValue(System::Drawing::Bitmap ^ Image, int i, int j, FuzzyFilters::coupleType type, int bigK)
{
	float max = 0.0f;
	for (int k = -bigK; k<= bigK; k++)
	{
		for (int l = -bigK; l<= bigK; l++)
		{
			float dist = FindDistance(Image, i, j, k, l, type);
			if (dist > max)
			{
				max = dist;
			}
		}
	}
	return max;
}


/**
* Calculates the weight assigned to the red component of each pixel within a neighborhood centered around (i,j).  
* These weights are then used to calculate the output image.
* @param Image - The image that Noise Reduction is being applied to
* @param i - An integer that together with j defines a specific pixel in Image
* @param j - see above.
* @param k - Used to access pixels that are part of a neighborhood centered around pixel (i,j)
* @param l - see above.
* @param bigK - Defines the size of a neighborhood. a neighborhood is (2*bigK + 1) x (2*bigK + 1) in size.  E.g. for bigK =1, we have a 3 x 3 neighborhood.
* @param rgP - A p value (see FindPValue() ) for a RedGreen couple.
* @param rbP - A p value (see FindPValue() ) for a RedBlue couple.
*
* @return the weight of the red component of a pixel within a neighborhood centered around (i,j)
* Primary Coder: Carlos Salazar
*/
float FuzzyFilters::RedWeight(System::Drawing::Bitmap ^ Image, int i, int j, int k, int l, int bigK, float rgP, float rbP)
{
	float rgDist = FindDistance(Image,i, j, k, l, FuzzyFilters::RedGreen);
	//float rgP = FindPValue(Image, i, j, FuzzyFilters::RedGreen, bigK);
	float rgMembership = SmallMembershipFunction(rgDist, rgP);

	float rbDist = FindDistance(Image,i, j, k, l, FuzzyFilters::RedBlue);
	//float rbP = FindPValue(Image, i, j, FuzzyFilters::RedBlue, bigK);
	float rbMembership = SmallMembershipFunction(rbDist, rbP);

	float weight = rgMembership * rbMembership;

	return weight;	
}

/**
* Calculates the weight assigned to the green component of each pixel within a neighborhood centered around (i,j).  
* These weights are then used to calculate the output image.
* @param Image - The image that Noise Reduction is being applied to
* @param i - An integer that together with j defines a specific pixel in Image
* @param j - see above.
* @param k - Used to access pixels that are part of a neighborhood centered around pixel (i,j)
* @param l - see above.
* @param bigK - Defines the size of a neighborhood. a neighborhood is (2*bigK + 1) x (2*bigK + 1) in size.  E.g. for bigK =1, we have a 3 x 3 neighborhood.
* @param rgP - A p value (see FindPValue() ) for a RedGreen couple.
* @param gbP - A p value (see FindPValue() ) for a GreenBlue couple.
*
* @return the weight of the green component of a pixel within a neighborhood centered around (i,j)
* Primary Coder: Carlos Salazar
*/
float FuzzyFilters::GreenWeight(System::Drawing::Bitmap ^ Image, int i, int j, int k, int l, int bigK, float rgP, float gbP)
{
	float rgDist = FindDistance(Image,i, j, k, l, FuzzyFilters::RedGreen);
	//float rgP = FindPValue(Image, i, j, FuzzyFilters::RedGreen, bigK);
	float rgMembership = SmallMembershipFunction(rgDist, rgP);

	float gbDist = FindDistance(Image,i, j, k, l, FuzzyFilters::GreenBlue);
	//float gbP = FindPValue(Image, i, j, FuzzyFilters::GreenBlue, bigK);
	float gbMembership = SmallMembershipFunction(gbDist, gbP);

	float weight = rgMembership * gbMembership;

	return weight;	
}

/**
* Calculates the weight assigned to the blue component of each pixel within a neighborhood centered around (i,j).  
* These weights are then used to calculate the output image.
* @param Image - The image that Noise Reduction is being applied to
* @param i - An integer that together with j defines a specific pixel in Image
* @param j - see above.
* @param k - Used to access pixels that are part of a neighborhood centered around pixel (i,j)
* @param l - see above.
* @param bigK - Defines the size of a neighborhood. a neighborhood is (2*bigK + 1) x (2*bigK + 1) in size.  E.g. for bigK =1, we have a 3 x 3 neighborhood.
* @param rbP - A p value (see FindPValue() ) for a RedBlue couple.
* @param gbP - A p value (see FindPValue() ) for a GreenBlue couple.
*
* @return the weight of the blue component of a pixel within a neighborhood centered around (i,j)
* Primary Coder: Carlos Salazar
*/
float FuzzyFilters::BlueWeight(System::Drawing::Bitmap ^ Image, int i, int j, int k, int l, int bigK, float rbP, float gbP)
{
	float rbDist = FindDistance(Image,i, j, k, l, FuzzyFilters::RedBlue);
	//float rbP = FindPValue(Image, i, j, FuzzyFilters::RedBlue, bigK);
	float rbMembership = SmallMembershipFunction(rbDist, rbP);

	float gbDist = FindDistance(Image,i, j, k, l, FuzzyFilters::GreenBlue);
	//float gbP = FindPValue(Image, i, j, FuzzyFilters::GreenBlue, bigK);
	float gbMembership = SmallMembershipFunction(gbDist, gbP);

	float weight = rbMembership * gbMembership;

	return weight;	
}

/*
* The main component of the Noise Reduction Algorithm.
* @param Image - The image that Noise Reduction is being applied to
* @param bigK - Defines the size of a neighborhood. a neighborhood is (2*bigK + 1) x (2*bigK + 1) in size.  E.g. for bigK =1, we have a 3 x 3 neighborhood.
*
* @return An Image with the fuzzy noise reduction subfilter applied to it.
* Primary Coder: Carlos Salazar
*/
System::Drawing::Bitmap^ FuzzyFilters::NRSubFilter1(System::Drawing::Bitmap ^ Image, int bigK)
{
	int w = Image->Width;
	int h = Image->Height;
	System::Drawing::Bitmap ^F = gcnew System::Drawing::Bitmap(w, h);

	//does the bitmap start at 0 or 1?
	for (int i = 0; i < h; i++)
	{
		for (int j = 0; j < w; j++)
		{
			float topR = 0.0f;
			float topG = 0.0f;
			float topB = 0.0f;

			float botR = 0.0f;
			float botG = 0.0f;
			float botB = 0.0f;

			//find the p value here...
			float rbp = FindPValue(Image, i, j, FuzzyFilters::RedBlue, bigK);
			float rgp = FindPValue(Image, i, j, FuzzyFilters::RedGreen, bigK);
			float gbp = FindPValue(Image, i, j, FuzzyFilters::GreenBlue, bigK);

			for (int k = -bigK; k<=bigK; k++)
			{
				for (int l = -bigK; l<=bigK; l++)
				{
					if (i+k < Image->Height && i+k >= 0 && j+l < Image->Width && j+l >= 0)
					{
						float rw = RedWeight(Image, i, j, k, l, bigK, rgp, rbp);
						float gw = GreenWeight(Image, i, j, k, l, bigK, rgp, gbp);
						float bw = BlueWeight(Image, i, j, k, l, bigK, rbp, gbp);

						topR += rw * Image->GetPixel(j+l, i+k).R;
						topG += gw * Image->GetPixel(j+l, i+k).G;
						topB += bw * Image->GetPixel(j+l, i+k).B;

						botR += rw;
						botG += gw;
						botB += bw;
					}
				}
			}

			int red = topR/botR;
			int green = topG/botG;
			int blue = topB/botB;

			F->SetPixel(j, i, Color::FromArgb(red, green, blue));
		}
	}

	return F;
}


/**
* Calculates local differences (aka gradients aka derivatives) for each element in the Image, uses these to "correct" the image.
* @param Image - The image that Noise Reduction is being applied to
* @param bigL - Defines the size of a neighborhood. a neighborhood is (2*bigL + 1) x (2*bigL + 1) in size.  E.g. for bigL =1, we have a 3 x 3 neighborhood.
*
* @return An image with the local differences subfilter applied to it.
* Primary Coder: Carlos Salazar
*/
System::Drawing::Bitmap^ FuzzyFilters::NRSubFilter2(System::Drawing::Bitmap ^ Image, int bigL)
{

	int w = Image->Width;
	int h = Image->Height;
	System::Drawing::Bitmap ^G = gcnew System::Drawing::Bitmap(w, h);

	int bottom = _Pow_int((2*bigL +1), 2); //(2L + 1)^2

	//
	for (int i = 0; i < h; i++)
	{
		for (int j = 0; j < w; j++)
		{
			float topR = 0.0f;
			float topG = 0.0f;
			float topB = 0.0f;

			for (int k = -bigL; k<=bigL; k++)
			{
				for (int l = -bigL; l<=bigL; l++)
				{
					if (i+k < Image->Height && i+k >= 0 && j+l < Image->Width && j+l >= 0)
					{
						Color px1 = Image->GetPixel(j+l,  i+k);
						Color px2 = Image->GetPixel(j, i);
						int ldr = px1.R - px2.R; //Local Difference for the Red component
						int ldg = px1.G - px2.G;
						int ldb = px1.B - px2.B;

						//"we calculate the average of the diffrence for the red, green, and blue component at the same position."
						float correctionTerm = (1/3)*(ldr + ldg + ldb); 

						topR += (px2.R + correctionTerm);
						topG += (px2.G + correctionTerm);
						topB += (px2.B + correctionTerm);
					}
				}
			}
			int red = topR/bottom;
			int green = topG/bottom;
			int blue = topB/bottom;

			G->SetPixel(j, i, Color::FromArgb(red, green, blue));
		}
	}
	return G;
}

/*
* Noise Reduction Filter.
* @param Image - The image that Noise Reduction is being applied to
* @param bigK - Defines the size of a neighborhood used in the 1st subfilter. a neighborhood is (2*bigK + 1) x (2*bigK + 1) in size.  E.g. for bigK =1, a 3 x 3 neighborhood.
* @param bigL - Same as bigK, but applied to the second subfilter.
*
* @return An image to which Noise Reduction filters have been applied.
* Primary Coder: Carlos Salazar
*/
System::Drawing::Bitmap^ FuzzyFilters::NoiseReduction(System::Drawing::Bitmap ^ Image, int K, int L) //Carlos
{
	//TODO: add a pop up window to gui to adjust K and L.
	/*
	* when K=1, filter uses (3x3) neighborhood.  When K=3, (7x7).
	*
	* From the paper:
	*
	* Best numerical & visual performance: K=1, L=1
	* for high levels of noise: K=2, L=1 was said to be best.
	*/
	System::Drawing::Bitmap ^ F = NRSubFilter1(Image, K);
	System::Drawing::Bitmap ^ G = NRSubFilter2(F, L);
	return F;
}

#pragma endregion


/**
*Reference from http://www.cgafaq.info/wiki/Image_Sharpening_and_Blurring
* Applies a fuzzy sharpening filter
* @param picture - the picture to apply a filter to
* @param redBool - indicates if you want to sharpening the red channel
* @param greenBool - indicates if you want to sharpening the green channel
* @param blueBool - indicates if you want to sharpening the blue channel
*
* @return An image to which the sharpening filter has been applied.
* Primary Coder: Liran Jiao
*/
System::Drawing::Bitmap^ FuzzyFilters::Sharpening(System::Drawing::Bitmap^ Image, bool redchecked, bool greenchecked, bool bluechecked, int option) //Liran
{
		int Width = Image->Width;
		int Height = Image->Height;
		Bitmap^ newBitMap = gcnew Bitmap(Width,Height);
		Color ^pixel;
		array<int> ^ Laplacian;
		if(option == 2)
		{
			array<int>^	LaplacianTmp = { -1, -4, -7, -4, -1,   
								-4, -16, -26, -16, -4,   
								-7, -26, 505, -26, -7,  
								-4, -16, -26, -16, -4,   
								-1, -4, -7, -4, -1};
			Laplacian = LaplacianTmp;
		}
		else if(option == 1)
		{
				array<int>^ LaplacianTmp = {-1, -1, -1,
								-1,  9, -1,
								-1, -1, -1};
				Laplacian = LaplacianTmp;
		}
		for (int x = option; x < Width - option; x++)
			for (int y = option; y < Height - option; y++)
		{
			int r = 0, g = 0, b = 0;
			int Index = 0;
			for (int col = -option; col <= option; col++)
				for (int row = -option; row <= option; row++)
			{
				pixel = Image->GetPixel(x + row, y + col);
				if(redchecked)
				{
					r += pixel->R * Laplacian[Index];
				}
				else
				{
					r = pixel->R;
				}
				if(greenchecked)
				{
					g += pixel->G * Laplacian[Index];
				}
				else
				{
					g = pixel ->G;
				}
				if(bluechecked)
				{
					b += pixel->B * Laplacian[Index];
				}
				else
				{
					b = pixel->B;
				}
				Index++;
			}
			if(redchecked)
			{
				if(option == 2)
				{
					r/= 273;
				}
				r = r > 255 ? 255 : r;
				r = r < 0 ? 0 : r;
			}
			if(greenchecked)
			{
				if(option == 2)
				{
					g/= 273;
				}
				g = g > 255 ? 255 : g;
				g = g < 0 ? 0 : g;
			}
			if(bluechecked)
			{
				if(option == 2)
				{
					b/= 273;
				}
				b = b > 255 ? 255 : b;
				b = b < 0 ? 0 : b;
			}
			//Color Overflow
			
			
			newBitMap->SetPixel(x-1, y-1,Color::FromArgb(r,g,b));
		}
		return newBitMap;


}

/*
* Zooms into the selected area of an image.
* @param pic - the image that the zoom is being applied to.
* @param startX - the starting x-coordinate of the selected rectangle.
* @param startY - the starting y-coordinate of the selected rectangle.
* @param endX - the ending x-coordinate of the selected rectangle.
* @param endY - the ending y-coordinate of the selected rectangle.
* @return An image that has been zoomed into.
* Primary Coder - Alex Munda
*/
System::Drawing::Bitmap^ FuzzyFilters::ZoomIn(System::Drawing::Bitmap^ pic, int startX, int startY, int endX, int endY)
{
	//Crop the image
	//Must change the starting and ending coordinates based on the way the user drags the box on the image
	int temp = 0;
	if(startX < endX && startY < endY);
	else if(startX > endX && startY > endY){
		temp = startX;
		startX = endX;
		endX = temp;
		temp = startY;
		startY = endY;
		endY = temp;
	}
	else if(startX > endX && startY < endY){
		temp = startX;
		startX = endX;
		endX = temp;
	}
	else if(startX < endX && startY > endY){
		temp = startY;
		startY = endY;
		endY = temp;
	}
	else{
		//Throw and error because they didnt select a valid rectangle
		throw 20;
	}
	int zoomFactor = 3;
	Rectangle cropRect = Rectangle(startX,startY, (endX-startX), (endY-startY));
	System::Drawing::Imaging::PixelFormat format = pic->PixelFormat;
	Bitmap^ croppedBitmap = pic->Clone(cropRect, format);
	System::Drawing::Image^ zoomed = (Image^)croppedBitmap;
	Bitmap^ b = gcnew Bitmap(zoomed,croppedBitmap->Width*zoomFactor, croppedBitmap->Height*zoomFactor);
	Bitmap^ sharpenedImage = FuzzyFilters::Sharpening(b, true, true, true, 2);
	return sharpenedImage;
	
}
